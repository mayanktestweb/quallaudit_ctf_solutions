# QuillCTF : assertEqual

## Object of CTF
So basically we need to write a Smart Contract with capability to check weather two given numbers are equal or not. If equal it should return 1 else somethingh else. Now the catch is that bytecode of this smart contract should be less than or equal to 40 Bytes and a list of bad opcodes is provided which includes Hex values that should not be present in the Smart Contract generated byte code.

## Phylosophy behind Solution Of CTF
Well, if one looks at the list of "Bad Opcodes", it includes all mathematical operations and logical operations too. So, clearly, we cant just deal with both numbers normally. I used a very simple approach to solve it. I took first number as a memory location to save value **1**, and then return whatever is saved in memory location indicated by second number. If second number is same as first one, it will return the 1 that we saved otherwise something else.

## Exact steps and solution of CTF
As metioned above we are going to save value "1" in memory, but there is a small problem and that is, along with all maths operations value 0x01 (opcode of Add) is also included. So to work around it I pushed 0x00 in stack and called **ISZERO**, which reads top of stack and if it finds 0 it replace it with 0x01, thus we can get 0x01 without including in our bytecode.
Second, problem is 0x04 (opcode of Divide) is also excluded, now we need 0x04 location as it is where in transaction calldata, we use to have our first argument of the function. Luckly in all testcases it is required to send value of **4 wei**, we will call **CALLVALUE** function to load 0x04 in our stack without using 0x04 in our bytecode. So following is mnemonics of code.

    PUSH0
    ISZERO
    CALLVALUE
    CALLDATALOAD
    MSTORE
    PUSH1 32
    PUSH1 0X24
    CALLDATALOAD
    RETURN

#### Huff code for above mnemonic code

    #define macro MAIN() = takes(0) returns(0) {
        0x00 iszero
        callvalue
        calldataload
        mstore
    
        0x20
        0x24 calldataload
        return
    }

Compile this huffcode and get bytecode. Note that foundry doesn't by default compile huff code, So you either have to install huffc or foundry-huff, In my case I have used huffc.

    $:/huffc assertEqual.huff --bytecode
    
    600c8060093d393df36000153435526020602435f3
    
Now, there is small problem in in bytecode above 600c8060**09**3d393df36000153435526020602435f3, which is the highlighted 0x09 which is part of bad opcodes. To resolve this let's investigate the bytecode untill first 0xf3 (bytecode for RETURN). **600c8060093d393df3**6000153435526020602435f3.
This part of the code simply returns the unhighlighted part code byte code and it only runs during the deployment. Let's look its mnemonics

    PUSH1 0x0c
    DUP1
    PUSH1 0x09       //// <--------
    RETURNDATASIZE
    CODECOPY
    RETURNDATASIZE
    RETURN

It's just deployment script which runs only one time and it returns the actual byte code of our written code. Looking at this it shows that 0x09 is indeed the position where our actual bytecode of contract starts in whole bytecode 600c8060093d393df3**6000153435526020602435f3**, 0x09 is the length of this deployment script bytecode. So, to defy it we will add an extra PUSH1 0X00 in deployment code, this will push the position of our contract bytecode to 0x0a instead of 0x09

    PUSH1 0x00
    PUSH1 0x0c
    DUP1
    PUSH1 0x0b       //// <--------
    RETURNDATASIZE
    CODECOPY
    RETURNDATASIZE
    RETURN


#### Huff code for above mnemocis

    #define macro MAIN() = takes(0) returns(0) {
        0x00 
        0x0c
        dup1
        0x0b
        returndatasize
        codecopy
        returndatasize
        return
    }

Compile this code too.

    $:/ huffc assertEqualSetup.huff --bytecode
    
    600b8060093d393df36000600c80600b3d393df3
    
Let's copy the code generated after first 0xf3 (opcode of RETURN), i.e, 600b8060093d393df3**6000600c80600b3d393df3** and replace the setupcode of our actual byte code with this new setup (or deployment) bytecode. It will give us following new bytecode.

    6000600c80600b3d393df36000153435526020602435f3
    
And that is our solution!!!.

## Proof Of Concept
### Foundry Test

*Create a .env file with following content and place it in your foundry root dir*

    MAINNET_RPC_URL=https://eth-mainnet.g.alchemy.com/v2/<Your-Alchemy-Api-Key>

Mind to replace it with your own Alchemy Api Key created for Mainnet in the end of above string.


    // SPDX-License-Identifier: MIT
    pragma solidity 0.8.7;
    
    import "forge-std/Test.sol";
    
    contract EQ is Test {
        address isNumbersEQContract;
        bytes1[] badOpcodes;
    
        string mainnetRpcUrl = vm.envString("MAINNET_RPC_URL");
    
        function setUp() public {
            badOpcodes.push(hex"01"); // ADD
            badOpcodes.push(hex"02"); // MUL
            badOpcodes.push(hex"03"); // SUB
            badOpcodes.push(hex"04"); // DIV
            badOpcodes.push(hex"05"); // SDIV
            badOpcodes.push(hex"06"); // MOD
            badOpcodes.push(hex"07"); // SMOD
            badOpcodes.push(hex"08"); // ADDMOD
            badOpcodes.push(hex"09"); // MULLMOD
            badOpcodes.push(hex"18"); // XOR
            badOpcodes.push(hex"10"); // LT
            badOpcodes.push(hex"11"); // GT
            badOpcodes.push(hex"12"); // SLT
            badOpcodes.push(hex"13"); // SGT
            badOpcodes.push(hex"14"); // EQ
            badOpcodes.push(hex"f0"); // create
            badOpcodes.push(hex"f5"); // create2
            badOpcodes.push(hex"19"); // NOT
            badOpcodes.push(hex"1b"); // SHL
            badOpcodes.push(hex"1c"); // SHR
            badOpcodes.push(hex"1d"); // SAR
            vm.createSelectFork(
                mainnetRpcUrl
            );
            address isNumbersEQContractTemp;
            // solution - your bytecode
            bytes
                memory bytecode = hex"6000600c80600b3d393df36000153435526020602435f3";
            
            require(bytecode.length < 40, "try harder!");
            for (uint i; i < bytecode.length; i++) {
                for (uint a; a < badOpcodes.length; a++) {
                    if (bytecode[i] == badOpcodes[a]) {
                        revert();
                    }
                }
            }
    
            assembly {
                isNumbersEQContractTemp := create(
                    0,
                    add(bytecode, 0x20),
                    mload(bytecode)
                )
                if iszero(extcodesize(isNumbersEQContractTemp)) {
    
                    revert(0, 0)
                }
            }
            isNumbersEQContract = isNumbersEQContractTemp;
        }
    
        // fuzzing test
        function test_isNumbersEq(uint8 a, uint8 b) public {
            (bool success, bytes memory data) = isNumbersEQContract.call{value: 4}(
                abi.encodeWithSignature("isEq(uint256, uint256)", a, b)
            );
            require(success, "!success");
            uint result = abi.decode(data, (uint));
            a == b ? assert(result == 1) : assert(result != 1);
    
            // additional tests
            // 1 - equal numbers
            (, data) = isNumbersEQContract.call{value: 4}(
                abi.encodeWithSignature("isEq(uint256, uint256)", 57204, 57204)
            );
            require(abi.decode(data, (uint)) == 1, "1 test fail");
            // 2 - different numbers
            (, data) = isNumbersEQContract.call{value: 4}(
                abi.encodeWithSignature("isEq(uint256, uint256)", 0, 3568)
            );
            require(abi.decode(data, (uint)) != 1, "2 test fail");
        }
    }

	

### Foundry test output
	$ forge test --match-path test/AssertEqual.t.sol
    [⠒] Compiling...
    [⠒] Compiling 1 files with 0.8.7
    [⠃] Solc 0.8.7 finished in 2.86s
    Compiler run successful
    
    Running 1 test for test/AssertEqual.t.sol:EQ
    [PASS] test_isNumbersEq(uint8,uint8) (runs: 256, μ: 40397, ~: 40396)
    Test result: ok. 1 passed; 0 failed; finished in 3.69s
